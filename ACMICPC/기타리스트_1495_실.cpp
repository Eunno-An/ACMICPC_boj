
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include<iomanip>

using namespace std;

/*
- endl 대신 '\n' 사용하기
- cin.tie(0) 사용
- 테스트 케이스 있는 문제일 시 전역변수 초기화 신경쓰기
- (A + B + C) % D = ((A + B) % D + C) % D
- 문자열 출력 문제는 정답 문자열 복사해서 코드에 넣기
- 괄호 사용 유의하기
- 문자열은 함수로 넘길 때 const & 잘 사용하기

- 최악의 경우 int 값 초과하는지, 배열 인덱스 초과하는지 확인
- n 범위 확인 (0인 경우), 양수음수 정수소수 확인, 불가케이스 -1 출력 등 확인
- 큰 배열 선언 시 전역선언, 테케 많을 시 초기화, 배열 용량 max N + 5
*/

#define MOD 1000000007
#define INT_MAX 987654321
#define MAX 100005

typedef long long int ll;
typedef pair<int, int> pii;

int N, S, M;
vector<int> V;
bool dp[110][1010];
int max_val = -1;
// 테스트 케이스 초기화 시
void init()
{
	
	
}
void find_Max(int now_idx, int before_val) {
	if (before_val == -1) {
		return;
	}
	if (now_idx == N) {
		int temp_max_val = -1;
		for (int i = 0; i < 2; i++) {
			if (dp[i][now_idx - 1] != -1) {
				if (temp_max_val < dp[i][now_idx - 1]) {
					temp_max_val = dp[i][now_idx - 1];
				}
			}
		}
		if (max_val < temp_max_val) {
			max_val = temp_max_val;
		}
		return;
	}
	int volume_dif = V[now_idx];
	if (before_val - volume_dif >= 0) {
		dp[0][now_idx] = before_val - volume_dif;
	}
	if (before_val + volume_dif <= M ) {
		dp[1][now_idx] = before_val + volume_dif;
	}
	now_idx++;

	for (int j = 0; j < 2; j++) {
		if (dp[j][now_idx - 1] != -1) {
			find_Max(now_idx, dp[j][now_idx - 1]);
		}
	}
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	init();
	cin >> N >> S >> M; // 곡의 개수, 시작 볼륨, M보다 큰 값
	int input;
	for (int i = 0; i < N; i++) {
		cin >> input;
		V.push_back(input);
	}
	/*if (S - V[0] >= 0) {
		dp[0][0] = S - V[0];
	}
	if (S + V[0] <= M) {
		dp[1][0] = S + V[0];
	}
	
	for (int i = 1; i <= N; i++) {
		for (int j = 0; j < 2; j++) {
			if (dp[j][i - 1] != -1) {
				find_Max(i, dp[j][i - 1]);
			}
		}
	}*/
	//만약 dp 배열이 계속 차있으면
	//2 2 2 2 2 2... 2 -> 2 ^100번 호출
	//cout << max_val << '\n';

	if (S + V[0] <= M) dp[0][S + V[0]] = true;
	if (S - V[0] >= 0) dp[0][S - V[0]] = true;
	for (int i = 1; i < N; i++) {
		for (int j = 0; j <= M; j++) {
			if (dp[i - 1][j]) {
				if (j + V[i] <= M) dp[i][j + V[i]] = true;
				if (j - V[i] >= 0) dp[i][j - V[i]] = true;
			}
		}
	}
	for (int i = M; i >= 0; i--) {
		if (dp[N-1][i]) {
			cout << i << '\n';
			return 0;
		}
	}
	cout << -1 << '\n';
	return 0;
}